//interpret.h

ConsCell* createEnvironment();
ConsCell* insertFrame(ConsCell *environment, Value *symbol, Value *binding);
Value* evalIf(ConsCell *boolean, ConsCell *first, ConsCell *second, ConsCell *env);
Value* resolveVariable(Value *val, ConsCell *cell);
Value* eval(ConsCell *expr, ConsCell *env);
Value* evalLet(ConsCell *varBinding, ConsCell *body, ConsCell *env);
Value* evalQuote(ConsCell *start);
void printValue(Value *evaluation);
void cleanupEnvironment(ConsCell* parentEnvironment);
Value* evalDefine(ConsCell *var, ConsCell *expr, ConsCell *env);
Value* evalLambda(ConsCell *params, ConsCell *body, ConsCell *env);
Value* createNullVal();
Value* applyFunc(Value* closure, ConsCell* expression, ConsCell* env);
Value* evalAddition(ConsCell *expr, ConsCell * env);
Value* evalNull(Value *expr, ConsCell* env);
Value *evalCar(Value *expr, ConsCell* env);
Value* mallocValue();
ConsCell* mallocConsCell();
void addToFreeList(void *pointer);
Value *evalBegin(ConsCell* expr, ConsCell* env);
Value* evalCond(ConsCell* expr, ConsCell* env);
Value* newCreateNullVal();
Value* setNullVal(Value* mlcdVal);
Closure* mallocClosure();
void freeList();
ConsCell* insertEnvironment(ConsCell *parentEnvironment);
Value* evalLetStar(ConsCell *varBinding, ConsCell *body, ConsCell *env);
Value *evalCdr(Value *expr, ConsCell* env);
Value *evalCons(Value *first, Value *second, ConsCell* env);
Value* evalSubtraction(ConsCell *expr, ConsCell* env);
Value* evalModulo(ConsCell *expr, ConsCell* env);
Value *evalEquals(ConsCell *expr, ConsCell* env);
Value *evalGreaterThan(ConsCell *expr, ConsCell* env);
Value *evalLessThan(ConsCell *expr, ConsCell* env);
Value *evalGreaterThanEqualTo(ConsCell *expr, ConsCell* env);
Value *evalLessThanEqualTo(ConsCell *expr, ConsCell* env);
Value* evalOr(ConsCell *expr, ConsCell* env);
Value* evalAnd(ConsCell *expr, ConsCell* env);
Value* evalDivision(ConsCell *expr, ConsCell *env);
Value* evalMultiplication(ConsCell *expr, ConsCell* env);